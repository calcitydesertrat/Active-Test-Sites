<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Test Sites Map</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <style>
    html, body, #map { height: 100%; margin: 0; }
    .note {
      position: absolute;
      top: 10px; left: 50%; transform: translateX(-50%);
      z-index: 1000;
      background: rgba(255,255,255,.9);
      padding: 8px 14px; border-radius: 6px;
      font: bold 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      letter-spacing: 1px; text-transform: uppercase;
      box-shadow: 0 2px 8px rgba(0,0,0,.12);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="note"><b>RED CIRCLES DEPICT HAZARDOUS OPERATIONS</b></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script>
    // === CONFIG ===
    const BASE_CSV_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSoErkMXLEG7xynznn0_opFq-rS8z9eQizEDL8e45E98AH9vHf7SwiwkvWoxFT_zeweec3iwIYNzbP1/pub?output=csv"; // .../pub?gid=0&single=true&output=csv
    const REFRESH_MS = 30000; // 30s

    // === MAP ===
    const map = L.map('map', { zoomControl: true }).setView([20, 0], 2);
    L.tileLayer(
      "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
      { maxZoom: 19, attribution: "Tiles © Esri — Source: Esri, Maxar, Earthstar Geographics" }
    ).addTo(map);

    const siteLayer = L.layerGroup().addTo(map);
    let siteGraphics = [];

    // === HELPERS ===
    function fromCols(row, names) {
      for (const n of names) if (row[n] !== undefined && row[n] !== "") return row[n];
      return undefined;
    }
    function toNumber(v) {
      if (v === undefined) return NaN;
      const s = String(v).trim().replace(/[°]/g, "");
      return parseFloat(s);
    }
    function metersFrom(row, base) {
      const m  = toNumber(fromCols(row, [base+"_m", base+"_M", base+"_meters", base+"_Meters"]));
      if (!Number.isNaN(m)) return m;
      const ft = toNumber(fromCols(row, [base+"_ft", base+"_FT", base+"_feet", base+"_Feet"]));
      if (!Number.isNaN(ft)) return ft * 0.3048;
      return 0;
    }

    function drawSite(row) {
      let lat = toNumber(fromCols(row, ["lat","Lat","latitude","Latitude"]));
      let lng = toNumber(fromCols(row, ["lng","Lng","lon","Lon","long","Long","longitude","Longitude"]));
      if (Number.isNaN(lat) || Number.isNaN(lng)) return;
      if (lat < -90 || lat > 90 || lng < -180 || lng > 180) return;

      const name      = fromCols(row, ["name","Name","site","Site","id","ID"]) || "Site";
      const statusRaw = fromCols(row, ["status","Status","STATUS"]) || "";
      const statusStr = String(statusRaw).trim();
      const isActive  = statusStr.toLowerCase() === "active";

      const qd  = metersFrom(row, "QD");
      const ptd = metersFrom(row, "PTD");
      const ptr = metersFrom(row, "PTR");

      // Circles only if site is ACTIVE
      const qdCircle  = (isActive && qd)  ? L.circle([lat, lng], { radius: qd,  color:'#e60000', fillColor:'#ff4d4d', fillOpacity:0.3,  weight:2 }) : null;
      const ptdCircle = (isActive && ptd) ? L.circle([lat, lng], { radius: ptd, color:'#f28e2b', fillColor:'#f28e2b', fillOpacity:0.25, weight:1 }) : null;
      const ptrCircle = (isActive && ptr) ? L.circle([lat, lng], { radius: ptr, color:'#a60000', fillColor:'#a60000', fillOpacity:0.2,  weight:1 }) : null;

      // Marker always shown — green if active, gray otherwise
      const marker = L.circleMarker([lat, lng], {
        radius: 6,
        color: isActive ? '#00a884' : '#777',
        fillColor: isActive ? '#00a884' : '#777',
        fillOpacity: 1,
        weight: 1.5
      }).bindPopup(`<strong>${name}</strong><br/>Status: ${statusStr || 'n/a'}`);

      return { marker, qdCircle, ptdCircle, ptrCircle };
    }

    function renderSites(graphics) {
      siteLayer.clearLayers();
      graphics.forEach(g => [g.ptrCircle, g.ptdCircle, g.qdCircle, g.marker].forEach(el => el && el.addTo(siteLayer)));
      const pts = graphics.map(g => g.marker.getLatLng());
      if (pts.length) map.fitBounds(L.latLngBounds(pts), { padding: [24,24] });
    }

    // === REFRESH LOOP (cache-busting + no overlap + solid change detection) ===
    let lastRawCSV = "";     // compare full text to detect any change
    let isLoading = false;   // avoid overlapping pulls

    function buildNoCacheUrl() {
      const sep = BASE_CSV_URL.includes("?") ? "&" : "?";
      // Add a moving 30s bucket to reduce re-downloads within the same half-minute if you prefer:
      // const bucket = Math.floor(Date.now() / 30000);
      // return `${BASE_CSV_URL}${sep}cb=${bucket}`;
      return `${BASE_CSV_URL}${sep}cb=${Date.now()}`; // strict no-cache each time
    }

    async function refreshOnce() {
      if (isLoading) return;
      isLoading = true;
      try {
        // Fetch raw CSV text with no-store to defeat intermediate caches
        const resp = await fetch(buildNoCacheUrl(), { cache: "no-store" });
        const csvText = await resp.text();

        // If identical to last pull, do nothing
        if (csvText === lastRawCSV && siteGraphics.length) return;

        lastRawCSV = csvText;

        // Parse CSV text via Papa (client-side)
        const parsed = Papa.parse(csvText, { header: true, dynamicTyping: false });
        const rows = parsed.data.filter(r => r && (r.lat || r.latitude || r.Lat || r.Latitude));

        siteGraphics = rows.map(drawSite).filter(Boolean);
        renderSites(siteGraphics);
      } catch (e) {
        console.error("Data refresh failed:", e);
      } finally {
        isLoading = false;
      }
    }

    // Kick off and self-schedule to avoid overlap
    (async function loop() {
      await refreshOnce();
      setTimeout(loop, REFRESH_MS);
    })();
  </script>
</body>
</html>
